# 表达式中的语句和声明
## `({...})`使用增添更多操作
使用圆括号（`(...)`）包裹的复合语句会被GCC识别为一个表达式，也就是说，你可以在其中使用循环，switch以及局部变量。
在复合语句中，由大括号（`{...}`）包裹一系列语句，因此，我们可以使用这样一种结构`({...})`，譬如：
```c
({
    int a = foo(x);
    int b;
    if(a > 0) b = a;
    else b = -a;
    b;
})
```
当然，这段代码对于编译器来说是有效的，并且最后会返回`b`的值，同时，我们知道这段代码中`a`和`b`的声明周期仅从声明处到符合语句结束。

我们将上面这段代码补全：
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int 
foo()
{
    struct timespec st = {0};
    timespec_get(&st, TIME_UTC);
    srand((unsigned int)st.tv_nsec);
    return rand()%10;
}

int
main(int argc, char * args[])
{
    for(int i = 0; i< 5; i++){
        int x = ({
            int a = foo(x);
            int b;
            if(a > 0) b = a;
            else b = -a;
            b;
        });
        printf("x = %d\n",x);
    }
    exit(0);
}
```
编译上面的代码，我们将得到五个`10`以内的随机数。

对于一个复合语句来说，其最后一项应该是一个表达式，当然，如果是其他类型的语句也是可以的，但是这会导致整个结构的类型为`void`，也就不再有值。

这一特性适用于使用宏定义时保证代码的安全性，譬如我们在标准C中通常这样定义一个判定较大值的`max(a,b)`宏函数：
```c
#define max(a,b)    ((a) > (b) ? (a) : (b))
```
但是这种定义方式在一些比较复杂的入参替换时（譬如：`max(x+y%2/10, z%3*5)`），会计算两次`a`或`b`，这显然是比较糟糕的。因此，当我们知道入参的数值类型时，就可以用下面这种方法来避免上面出现的情况：
```c
#define maxint(a,b) \
    ({\
        int _a = (a), _b = (b);\
        _a > _b ? _a : _b;\
    })
```
很显然，这样就可以避免入参`a`和`b`的多次计算。
    
但是显然，在这种声明中应该考虑变量遮蔽的问题，譬如我们使用如下的调用方式：
```c
int _a = 1, _b = 2;
int c = maxint(_a, _b);
```
这段代码在经过预处理后，会被替换成如下代码：
```c
int _a = 1, _b = 2;
int c = 
    ({
        int _a = (_a), _b = (_b);
        _a > _b ? _a : _b;
    });
```
显然，由于变量名相同，导致在外部的变量`_a`和`_b`被复合语句内部的同名变量遮挡，导致最后的数值错误，但从程序语法来说，编译器并没有检查出什么问题。

让我们再将上面的例子变得更复杂一点，例如，我们递归它：
```c
#define maxint3(a, b, c) \
    ({\
        int _a = (a), _b = (b), _c = (c);\
        maxint(maxint(_a, _b), _c);\
    })
```
很显然，这次我们甚至不需要在外面定义`_a`和`_b`：
```c
int n = maxint3(2, 3, 5);
```
将会被替换为：
```c
int n = 
    ({
        int _a = (2), _b = (3), _c = (5);
        ({
            int _a =
            (({
                int _a = (_a), _b =(_b);
                _a > _b : _a : _b;
            })), _b = (_c);
            _a > _b ? _a : _b;
        })
    });
```
显然，由于同名变量导致的变量遮盖，这段代码最后的结果并不会理想。

    在常量表达式（如：初始化静态变量的值、位域宽度、枚举常量）中，不允许嵌入语句。

当我们使用复合表达式语句和函数调用时，需要注意到其中的临时变量的生命周期问题。对于函数调用来说，其实参求值期间引入的临时变量是在所调用函数执行完毕返回时销毁；但是对于符合表达式，其临时变量用完即销毁，并不会留存下来。我们用下面的代码来解释这一现象：
```c
#include <stdlib.h>
#define macro(a) ({int b = (a); b + 3; })
int 
X()
{
    return 5;
}

int 
func(int a) 
{
    int b = a; 
    return b + 3; 
}

int 
main(int argc, char * argv[])
{
    macro(X());
    func(X());
    exit(0);
}
```
显然，对于`macro()`来说，传递的参数`X()->5`会在执行完`int b = (a)`后销毁，但是对于函数调用`func()`来说，传递的参数会被接收到参数`a`，并在函数返回时才进行销毁。

## 局部标签声明

# 增添属性