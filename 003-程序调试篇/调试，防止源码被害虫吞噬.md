# 调试——代码完善的必经之路
一个工程的完成会从需求定义开始，经过整体和细节的设计、编码、测试和调试等各个阶段。

在编写代码时，如果程序员感觉到自己的代码完成到某种程度时，就应该主动进行编译和构建，修改并消灭编译错误和构建错误。

    编写代码->编译->编译错误->能否启动
        ^              |         |
        |--------------+         |
        |------------------------+

编译错误被消灭后，虽然整体功能尚未完成，但对于某一个模块来说，应该是可以运行的，可以对单个模块进行测试，观察其行为是否与预期一致。这并不是正式的测试，而是在编码阶段查看能否启动与运行，不能启动或出现崩溃等问题，就应该在进入测试阶段之前全部改掉。

在编码阶段完成后就是测试与调试阶段，测试是确认程序是否与设计阶段所设计的结果一致，也就是说，程序能否给出令人满意的输出。若出现与期待行为不一致的情况，我们就将其称为 bug 。测试就是寻找程序中 bug 的过程。

bug 有时不会在正式测试阶段发现，但也可能在之后的使用中暴露出来，发现 bug 的方式多种多样。但不论是哪一种情况，调试总在 bug 被确认之后开始。

有的主张认为在编写程序之前应该先编写测试程序，这种方法成为 TDD（测试驱动开发：Test-Driven Development）。

调试的流程可以表述为一个环形结构

     编码 -> 测试
       ^       |
       |-调试<-|

一个调试的流程应该如下：

1. bug 复现。
2. 调试。
3. 确认执行过程（测试）。
4. 程序行为与预期相同，停止调试；程序行为与预期不同，转到 `2.`。
---------------------------
### **内核出现问题时：**

|区分方法       |结果                               |
|----           |-----                              |
|ps             |显示中途停止，状态为D              |
|ping           |不返回响应                         |
|键盘           |键盘无法输入                       |
|kill -9        |无法结束程序                       |
|strace         |无法附加（attach）到进程（无项应） |
|gdb            |无法附加（attach）到进程（无项应） |
|查看内核信息   |softlockup 等有输出结果            |

发现bug之后的重要工作是以 dump（转储文件）为提示复现 bug 。

### 复现之前
#### **配置环境的一致性**
发现 bug 之后就该进行调试工作，但在不同的工作环境（硬件环境或软件版本不同）中确认 bug 时，其行为可能不同。如果可以，最好在bug发生的机器上复现，如果无法做到，应当尽可能让复现环境与bug的发生环境一致。硬件和软件都相同的环境是最理想的情况。

#### **听取他人的意见**
试图复现他人发现的 bug 时，如果有疑问或者需要更多的信息，应该在总结之后一起询问，反复询问一些细小的问题会让人感到疲倦和厌烦，所以应该先自己操作一遍，之后将问题与疑难总结再提问。有时，有一些对方觉得与 bug 无关，但实际上十分重要的东西，应该在听取时考虑到这些问题。

### 复现之后
#### **确认是否真的复现**
有时，看似复现了bug，其实是完全不同的现象，因此在感觉到成功复现后，先别太开心，再确认以下是否真的复现了。

#### **确认复现概率和时间**
bug 是否是100%复现？对于不同的复现概率，使用的调试方法和时间是完全不同的。并且，有些 bug 需要软件在执行很久之后才能复现，而有些 bug 在软件刚开始运行时就可以复现。因此弄清楚复现的概率和时间是十分重要的。

## 在专用目录中生成内核转储
使用大型文件系统时，会希望将内核转储放在固定位置。默认情况下放在当前目录中生成，但是可能南衣浓情文件到底在哪里生成。此外，大量生成的内核转储文件可能会给系统的磁盘空间造成压力，因此设置专用的内核转储存储分区，在此处存放内核转储文件就可以方便很多。转储保存的位置的完成路径可以通过`sysctl`变量`kernel.core_pattern`设置。设置方法如下：
```shell
[root]:  echo "kernel.core_pattern = /var/core/%e-%t.core" >> /etc/sysctl.conf
```
其格式化命名规则如下：
|格式符 |说明                                 |
|---    |---                                  |
|%%     |%符号本身                            |
|%p     |被转储进程ID(PID)                    |
|%u     |被转储进程真实用户ID(real UID)       |
|%g     |被转储进程真实组ID(real GID)         |
|%s     |引发转储的信号编号                   |
|%t     |转储时刻(1970/1/1 00:00 开始的秒数)  |
|%h     |主机名(同uname返回的nodename)        |
|%e     |可执行文件名                         |
|%c     |转储文件的大小上限                   |

如果我们希望自定义PID在转储文件命名中的位置时，将`sysctl`变量`core_uses_pid`设置为`0`。即：
```shell
[root]:  echo "kernel.core_uses_pid = 0" >> /etc/sysctl.conf
```
若此值为`1`，则会在文件名末尾添加`PID`。
当然也可以加入管道，启动用户模式辅助程序，例如：
```shell
[root]:  echo "|/usr/local/sbin/core_helper %e %t %p" > /proc/sys/kernel/core_pattern
```
实际上，这里的`core_pattern`的内容即为`sysctl`变量`core_pattern`的值，因此将其覆盖重写即可。

然后我们在`/usr/local/sbin/core_helper`中写入如下内容即可：
```shell
#!/bin/sh
exec gzip - > /var/core/$1-$2-$3.core.gz
```
这样，内核转储时就会在`/var/core/`下生成压缩的内核转储文件。
